#!/usr/bin/env python
import argparse, os, sys
from utils import utilities, mputils
from flipper import flipperDict
import tempfile, datetime


def taskFunc(params, valToUpdate, paramsToUpdate, className, runName):
    """
    @brief update the params
    """
    
    classFunc = utilities.stringToFunction(className)
    runFunc = getattr(classFunc, runName)
    
    # update the parameter dictionary
    newParams = utilities.update_dict(params, valToUpdate, paramsToUpdate)
        
    # instantiate the class
    c = classFunc(newParams)
    
    # run the method, with class as first argument
    runFunc(c)
    
    return 0
    
def setup_output():
    
    # redirect stdout, stderr to a file
    sys.stderr = tempfile.TemporaryFile()
    
    fileName, extension = os.path.splitext(os.path.basename(sys.argv[0]))
    sys.stdout = open(os.getcwd() + os.sep + "%s.%d.out" %(fileName, os.getpid()), 'w')
    
    return
    
def finish_output():
    
    # append the temp stderr to stdout file
    sys.stdout.write('%s\n' %('-'*150))
    sys.stderr.seek(0)
    sys.stdout.write(sys.stderr.read())
    sys.stdout.write('%s\n' %('-'*150))
    
    # print out finish time
    now = datetime.datetime.now()
    sys.stdout.write("job finished at %s\n\n" %str(now))
    
    return
    

def batchrun(p, args):
    
    # read in the parameters we'll need to update
    params = flipperDict.flipperDict()
    params.readFromFile(p['paramFile'])
    
    
    # do serial if nprocs = 1
    if args.np == 1:
        
        setup_output()
        
        try:
            for i in p['valsToUpdate']:
                taskFunc(params, i, p['paramsToUpdate'], p['className'], p['runFunc'])
        except:
            raise
        finally:
            finish_output()
    
    # do parallel operations
    else:
        
        # initialize the multiprocessing master with nprocs
        master = mputils.mp_master(args.np, len(p['valsToUpdate']))
    
        # enqueue the tasks
        for cnt, i  in enumerate(p['valsToUpdate']):
            master.enqueue(mputils.task(taskFunc, params, i, p['paramsToUpdate'], p['className'], p['runFunc'], num=cnt ))
        
        # start the work and wait until it finishes
        master.run()
    
    return 
        

if __name__ == '__main__':
    
    # parse the input arguments
    parser = argparse.ArgumentParser(description="run a given executable in batch mode, with specified parameters")
    parser.add_argument('param_file', type=str, help='the parameter file') 
    parser.add_argument('--np', type=int, default=1, help="number of processors to use")
    parser.add_argument('-q', '--quiet', action='store_true', default=False, help='whether to ouput to std out')
  
    args = parser.parse_args()

    # read in the parameter file
    p = flipperDict.flipperDict()
    p.readFromFile(args.param_file)
    
    # if we want to suppress out, redirect stdout to nothing
    if args.quiet:
        sys.stdout = open(os.devnull, "w")
    
    batchrun(p, args)